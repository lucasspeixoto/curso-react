React

* Single page application: O React é um framework de uma única página (public/index.html), que vai ter uma div com id 'root', onde será renderizado todos os nossos elementos.

* React utiliza a sintaxe jsx, que permite escrever elementos, da mesma forma que escrevemos em códigos html, ou seja, por tras, terá um interpretador que vai transformar essa sintaxe em JavaScrip

Ex:
  import React from 'react';
  import ReactDOM from 'react-dom';
  import './index.css';
  import App from './main/App';
  import reportWebVitals from './reportWebVitals';

  ReactDOM.render(
    <React.StrictMode> {/* Sintaxe jsx */}
      <App />
    </React.StrictMode>,
    document.getElementById('root')
  );

  reportWebVitals();

* Uma das ideias por tras dos componentes, é a reutilização, podemos reutilizar um componente quantas vezes for necessário

Ex: 
 import React from 'react'
 import ReactDOM from 'react-dom'
 import './index.css'

 import Primeiro from './components/basics/Primeiro'
 import ComParametro from './components/basics/ComParametro'

 ReactDOM.render(
     <div>
         <Primeiro></Primeiro>
         <ComParametro titulo="Situação do aluno"
                      nome="Liana" nota={9.8} />
         <ComParametro titulo="Situação do aluno"
                      nome="Lucas" nota={9.1} />
     </div>,
     document.getElementById('root')   
 )

* As propriedades passadas como parâmetro de um componente são imutáveis, todas são somente leitura. Caso seja necessário renderizar um parâmetro que 'pode' variar, é necessário criar uma variável auxiliar.

* Um componente não pode retornar isoladamente dois ou mais componentes, esses componentes precisam ser envolvidos por uma div, ou, com algumas elementos especializados do React, como React.Fragment ou React.StrictMode.

* O StrictMode do React é uma espécie de componente auxiliar que o ajudará a escrever melhores componentes, você pode agrupar um conjunto de componentes com <StrictMode /> e basicamente:

Verificam se os componentes internos estão seguindo algumas das práticas recomendadas e avise se não estiverem no console.
Verificam se os métodos obsoletos não estão sendo usados ​​e, se forem usados, o modo estrito o avisará no console.
 Ajudam a prevenir alguns efeitos colaterais, identificando riscos potenciais.
Como diz a documentação, o modo estrito é orientado para o desenvolvimento, então você não precisa se preocupar com o impacto na construção de sua produção.

Achei especialmente útil implementar o modo estrito quando estou trabalhando em novas bases de código e quero ver que tipo de código / componentes estou enfrentando. Além disso, se você estiver no modo de caça a bugs, às vezes é uma boa ideia envolver com <StrictMode /> os componentes / blocos de código que você acha que podem ser a fonte do problema.

Então sim, você está no caminho correto para entender o modo estrito, continue, acho que é uma daquelas coisas que você entende melhor quando joga com eles, então vá em frente e divirta-se.

* Uma forma de passar um parâmetro que não é utilizado, é através do underline (_)

Ex:
export default _ => {

    return (
    <React.StrictMode>
        <Primeiro></Primeiro>
        <ComParametro titulo="Situação do aluno"
                      nome="Liana" nota={9.8} />
        <ComParametro titulo="Situação do aluno"
                      nome="Lucas" nota={6.1} />
    </React.StrictMode>
    )
}

* Para passar um componente dentro de outro, e exibir todas as propriedades do elemento filho, precisamos utilizar o 'props.children'

Ex: 
 -> App.jsx:
	import React from 'react'
	import Primeiro from './components/basics/Primeiro'
	import ComParametro from './components/basics/ComParametro'
	import Aleatorio from './components/basics/Aleatorio'
	import Card from './components/layout/Card'

	export default _ => {

    	return (
        	<React.StrictMode>
            	<Card titulo = "Desafio Aleatório">
                	<Aleatorio className="Card" min={1} max={50}/>
            	</Card>
        	</React.StrictMode>
    		)
			   }

 -> Aleatorio.jsx:
	import React from 'react'
	export default props => {
    	const {min, max} = props
    	const aleatorio = Math.floor(Math.random() * (props.max - props.min) + props.min)
    	return (
        	<div>
            	<h2>Valor Aleatório</h2>
            	<p>Mínimo: <strong> { min }</strong></p>
            	<p>Máximo: <strong> { max }</strong></p>
            	<p>Aleatório: <strong> { aleatorio }</strong></p>
        	</div>
    		)
				}

 -> Card.jsx:
	import React from 'react'
	import './Card.css'

	export default props => {
    	return (
        	<div className="Card">
           		<div className="Title">{props.titulo}</div>
            		<div className="Content">
                		{props.children}
            		</div>
       		 </div>
    	)
	}

* Passando propriedades de Pai (Familia) para filho (FamiliaMembro)
  -> FamiliaMembro.jsx:

	import React from 'react'
	export default props => {
    	return <span>{props.nome} <strong>{props.sobrenome}</strong></span> 
	}

  -> Familia.jsx:
	import React from 'react'
	import FamiliaMembro from './FamiliaMembro'

	export default props => {
    	return (
        <div>
            	<p><FamiliaMembro nome="Liana" sobrenome={props.sobrenome} /></p>
            	<p><FamiliaMembro nome="Cecilia" {...props} /></p>
            	<p><FamiliaMembro nome="Cesar" sobrenome="Peixoto Fernandes" /></p>
        </div>
    )
}

 -> App.jsx:

import React from 'react'
import Primeiro from './components/basics/Primeiro'
import ComParametro from './components/basics/ComParametro'
import Aleatorio from './components/basics/Aleatorio'
import Card from './components/layout/Card'
import Familia from './components/basics/Familia'
import './App.css'
 
export default _ => {

    return (
        <div className="App">
            <h1>Fundamentos React</h1>
            <div className="Cards">
                <Card titulo="#04 - Componentes com Filhos" color="#5B2C6F ">
                    <Familia sobrenome="Peixoto Fernandes"/> {/* Aqui, passamos para Familia, o sobrenome, que é passado ao FamiliaMembro através do Familia.jsx */}
                </Card>

                <Card titulo="#03 - Desafio Aleatório" color="#080">
                    <Aleatorio className="Card" min={1} max={50} />
                </Card>

                <Card titulo="#02 - ComParametro" color="#008">
                    <ComParametro
                        titulo="Situação do Aluno"
                        nome="Liana Fernandes"
                        nota={9.8} />
                </Card>

                <Card titulo="#01 - Primeiro Componente" color="#fcad03">
                    <Primeiro />
                </Card>
            </div>
        </div>
    )
}

* No exemplo anterior, conseguimos passar as propriedades do Pai (Familia) para o filho (FamiliaMembro), pois, estavamos definindo os membros dentro de Familia.jsx, ou seja, tinhamos acessos as propriedades dos filhos, e só foi necessário passar o sobrenome com sobrenome = props.sobrenome.
Se passar os filhos, dentro de Familia, em App.jsx, precisamos sinalizar as propriedades dos pais em Familia.jsx:

 -> Em Familia.jsx:
	import React, { cloneElement } from 'react'

	export default props => {
    	return (
        	<div>
            	{React.Children.map(props.children, (child) => {
                	return cloneElement(child, props)
            	})}
        	</div>
    	)
	}
Com React.Children.map, percorremos toda a lista de filhos (props.children), e para cada filho, retornamos um elemento clonado com as propriedades dos filhos e tambem dos pais.

 -> Em App.jsx:
import React from 'react'
import Primeiro from './components/basics/Primeiro'
import ComParametro from './components/basics/ComParametro'
import Aleatorio from './components/basics/Aleatorio'
import Card from './components/layout/Card'
import Familia from './components/basics/Familia'
import FamiliaMembro from './components/basics/FamiliaMembro'
import './App.css'

export default _ => {

    return (
        <div className="App">
            <h1>Fundamentos React</h1>
            <div className="Cards">
                <Card titulo="#04 - Componentes com Filhos" color="#5B2C6F ">
                    <Familia sobrenome="Peixoto Fernandes">
                        <FamiliaMembro nome="Liana" />
                        <FamiliaMembro nome="Cecilia" />
                        <FamiliaMembro nome="Cesar" />
                    </Familia>
                </Card>
            </div>
        </div>
    )
}


* Toda vez que trabalhamos com arrays em React, precisamos usar chaves(keys), para facilitar o React no momento de identificar alterações em elementos dos arrays. Os elementos serão renderizados normalmente sem as chaves, porem, pode ocorrer problemas para lidar com alterações.

Ex:

 -> Em alunos.js:
export default [
    {id: 1, nome: "Ana", nota: 6.2},
    {id: 2, nome: "Bia", nota: 8.7},
    {id: 3, nome: "Carlos", nota: 6.8},
    {id: 4, nome: "Pedro", nota: 7.7},
    {id: 5, nome: "Alice", nota: 7.1},
    {id: 6, nome: "Oliver", nota: 5.8},
    {id: 7, nome: "Olinda", nota: 6.2},
    {id: 8, nome: "Cecilia", nota: 8.6},
    {id: 9, nome: "Cesar", nota: 9.2},
]

 -> Em ListaAlunos.jsx:
import React from 'react'
import alunos from '../../data/alunos'
export default _ => {

    const Alunos = alunos.map(aluno => {
        return (
        <li key={aluno.id}>
            {aluno.id}- {aluno.nome} - {aluno.nota}
        </li>
        )
    })
    return (
        <div>
            <ul>
                {Alunos}
            </ul>
        </div>
    )
}

* A Renderização condicional é possíve através de operadores ternários ou de componentes If's Else's.

Ex:

 -> Em If.js:
export default props => {
    
    const elseChild = props.children.filter(child => {
        return child.type && child.type.name === 'Else'
    })[0]

    const ifChildren = props.children.filter(child => {
        return child !== elseChild
    })

    if(props.test) {
        return ifChildren
    } else if(elseChild) {
        return elseChild
    } else {
        return false
    }
}

export const Else = props => props.children

 -> Em UsuarioInfo.jsx:
import React from 'react'
import If, {Else} from './If'

export default props => {
    const usuario = props.usuario || {}
    return (
        
        <div>
            {/* 
	    Caso tenha o parâmetro nome 
            <If test={usuario && usuario.nome}>
            Seja bem vindo(a) <strong>{usuario.nome}!</strong>
            </If>
            
            <If test={!usuario || !usuario.nome}>
            Seja bem vindo(a) <strong>Pessoa!</strong>
            </If>
	    */}

            <If test={usuario && usuario.nome}>
                Seja bem vindo(a) <strong>{usuario.nome}!</strong>
                <Else>
                    Seja bem vindo(a) <strong>Estranho!</strong>
                </Else>
            </If>
        </div>
    )
}

 -> Em ParOuImpar.jsx:
import React from 'react'

export default props => {
    const isPar = props.numero % 2 === 0
    return (
        <div>
            { isPar ?
                <span>Par</span> :
                <span>Ímpar</span>
            }
        </div>
    )
}

 -> Em App.jsx:
export default _ => {
    return (
        <div className="App">
            <h1>Fundamentos React</h1>
            <div className="Cards">
                <Card titulo="#07 - Renderização Condicional" color="#1C2833">
                    <ParOuImpar numero = {22}/>
                    <UsuarioInfo usuario={{nome: 'Liana'}} />
                    <UsuarioInfo usuario={{nome: 'Lucas'}} />
                    <UsuarioInfo usuario={{email: 'fulano@gmail.com'}} /> {/*Não possue nome, cai no 'Else'*/}
                </Card>
            </div>
        </div>
    )
}

* A comunicação de um componente pai para um componente filho é realizada através de props, uma comunicação direta.

Ex: 
 -> Em DiretaFilho.jsx:
export default props => {
    return (
        <div>
            <span>{props.nome} - </span>
            <span>{props.idade} - </span>
            <span>{props.nerd ? 'Verdadeiro' : 'Falso'}</span>
        </div>
    )
}

 -> Em DiretaPai.jsx:
import React from 'react'
import DiretaFilho from './DiretaFilho'
export default props => {
    return (
        <div>
            <DiretaFilho nome="Cecília" idade={4} nerd={true}></DiretaFilho>
            <DiretaFilho nome="César" idade={3} nerd={false}></DiretaFilho>
            <DiretaFilho nome="Charlote" idade={1} nerd={false}></DiretaFilho>
        </div>
    )
}

 -> Em App.jsx:

import React from 'react'
import Card from './components/layout/Card'
import DiretaPai from './components/comunicacao/DiretaPai'

import './App.css'

export default _ => {

    return (
        <div className="App">
            <h1>Fundamentos React</h1>
            <div className="Cards">
                <Card titulo="#08 - Tipos de Comunicação" color="#59323C">
                    <DiretaPai></DiretaPai>
                </Card>
            </div>
        </div>
    )
}

* A comunicação de um componente filho para um componente pai, ocorre de forma indireta, e pode ser programada com uma função para passagem dos parâmetros.
O pai que tem uma comunicação direta com o filho, via props, passa uma função, e essa função, é uma função callback, que será chamada em algum momento, ou seja, quando acontecer algum evento no filho, a função foi chamada e passou as propriedades do componente filho para o componente pai.

Ex:

 -> Em IndiretaPai.jsx:
import React, { Fragment } from 'react'
import IndiretaFilho from './IndiretaFilho'
export default props => {

    // nome idade nerd
    function fornecerInformacoes(nome, idade, nerd) {
        console.log(nome, idade, nerd)
    }
    return (
        <Fragment>
            <div>Pai</div>
            <IndiretaFilho quandoClicar={fornecerInformacoes}></IndiretaFilho>
        </Fragment>
    )
}

 -> Em IndiretaFilho.jsx:
import React, {Fragment} from 'react'
export default props => {
    return (
        <Fragment>
            <div>Filho</div>
            <button onClick={
                function (event) {
                    props.quandoClicar('Lucas', 29, true)
                }
            }>
                Fornecer Informações
            </button>
        </Fragment>

    )
}

* Para passar esses valores de parâmetros retornados pela função, precisamos inclui-los no componente pai, ou sejam definir variaves para esses parâmetros e atribuilas dentro da função callback que é chamada no componente filho. Além disso, será necessário trabalhar com o estado do componente, e passar essas alterações de propriedades do pai, que passam a ser as do filho.
Para isso, podemos usar o Hooks 'useState', que é uma função que retorna um array de duas posições, a primeira é o valor, e a segunda uma função responsável por alterar o valor

const [nome, setNome] = useState("?")
nome, vai receber o valor desse nome, e setNome, vai receber a função responsável por alterar o nome.

Ex: 
 -> Em IndiretaFilho.jsx:

import React, {Fragment} from 'react'
export default props => {

    const gerarIdade = () => Math.floor(Math.random() * (40) + 20)
    //const gerarNerd = () => parseInt((Math.random() * (1) + 0).toFixed(0))
    const gerarNerd = () => Math.random() > 0.5
    return (
        <Fragment>
            <div>Filho</div>
            <button onClick={
                function (event) {
                    props.quandoClicar('Lucas', gerarIdade(), gerarNerd())
                }
            }>
                Fornecer Informações
            </button>
        </Fragment>

    )
}
 -> Em IndiretaPai.jsx:
import React, { Fragment, useState } from 'react'
import IndiretaFilho from './IndiretaFilho'
export default props => {

    const [nome, setNome] = useState("?") 
    const [idade, setIdade] = useState(0)
    const [nerd, setNerd] = useState(false)

    // nome idade nerd
    function fornecerInformacoes(nome, idade, nerd) {
        setNome(nome)
        setIdade(idade)
        setNerd(nerd)
    }
    return (
        <Fragment>
            <div>
                <span>{nome} </span>
                <span>{idade} </span>
                <span>{nerd ? 'Verdadeiro' : 'Falso'} </span>
            </div>
            <IndiretaFilho quandoClicar={fornecerInformacoes}></IndiretaFilho>
        </Fragment>
    )
}

* Campos HTML como <input>, <textarea> e <select>, ao serem criados como componentes React, de inicio não vamos conseguir alterar os valores na interface, pois o caminho de alteração dos estados é unidirecional, ou seja, o estado altera a interface gráfica, não o contrário.

Ex:

 -> Em Inputs.jsx:
import React, { useState } from 'react'
import './Inputs.css'

export default (props) => {

    const [valor, setValor] = useState('Inicial');
    
    function quandoMudar(e) {
        setValor(e.target.value) {/* Aqui indicamos para mudar o valor */}
    }

    return (
        <div className="Inputs">
            <h2>{valor}</h2>
            <div style ={{
                display: 'flex',
                flexDirection: 'column'
            }}>
                <input value={valor} onChange={quandoMudar} />
                <input value={valor} readOnly />
                <input value={undefined} />
            </div>
        </div>
    )
}

* Todos os componentes que usamos, foram baseados em funções, porem, o React permite a construção de componentes baseados em classes, que possui poucas diferenças para os componentes funcionais, possui algums metodos de ciclos de vida a mais, porem, com os hooks, com os componentes funcionais poderemos lidar com quase todos os cenários envolvendo ciclos de vida.

* Trabalhando com um componente baseado em classe, para alterar o estado desse componente com o this.setState, precisamos indicar para onde o this apontar, pois na chamada da função em <button onClick={this.incrementar}>Incrementar</button>, o this não aponta para o objeto atual, para isso, temos algumas soluções:

1ª:
constructor(props){
   super(props)
   this.incrementar = this.incrementar.bind(this)
}

2ª: Transformar a função em uma função arrow, que sempre vai apontar o this para o objeto atual
incrementar = () => {
   this.setState({
      numero: this.state.numero + 1
        })
    }

3ª: Usar uma função arrow na chamada da função
<button onClick={e => this.incrementar()}>Incrementar</button>

* Podemos dividir nosso contador em tres componentes, Display, PassoForm e Botoes, para isso, será necessário fazer uso da comunicação entre o componente pai (Contador) e os componentes filhos (Display, PassoForm e Botoes).

Ex:

 -> Em Display.jsx:
import React from 'react'

export default props => {
    return (
        <h3><strong>{props.numero}</strong></h3>
    )
}

 -> Em Botoes.jsx:
import React from 'react'

export default props => {
    return (
        <div>
            <button onClick={props.setInc}>+</button>
            <button onClick={props.setDec}>-</button>
        </div>
    )
}

 -> Em PassoForm.jsx:
import React from 'react'

export default (props) => {
    return (
        <div>
            <label htmlFor="passoInput">Passo: </label>
            <input
                id="PassoInput"
                type="number"
                value={props.passo}
                onChange={e => props.setPasso(+e.target.value)}
            />
        </div>
    )
}

 -> Em Contador.jsx:
import React, { Component, useState } from 'react'
import "./Contador.css"
import Display from './Display'
import PassoForm from './PassoForm'
import Botoes from './Botoes'

export default class Contador extends Component {

    //1ª Forma de inicializar o estado
    state = {
        numero: this.props.numeroInicial || 0, //Inicializando o valor
        passo: this.props.passoInicial || 1
    }

    /*2ª Forma de inicializar o estado
    constructor(props){
        super(props)
        this.state = {
            numero: this.props.numeroInicial
        }
    }
    */

    incrementar = () => {
        this.setState({
            numero: this.state.numero + this.state.passo
        })
    }

    decrementar = () => {
        this.setState({
            numero: this.state.numero - this.state.passo
        })
    }

    setPasso = (novoPasso) => {
        this.setState({
            passo: novoPasso,
        })
    }

    render() {
        return (
            <div className="Contador">
                <h2>Contador</h2>
                <Display numero={this.state.numero}></Display>
                <PassoForm passo={this.state.passo} setPasso={this.setPasso}></PassoForm>
                <Botoes setInc={this.incrementar} setDec={this.decrementar} ></Botoes>
            </div>
        )
    }
}

Aqui, entre PassoForm e Contador, temos os dois tipos de comunicação, direta e indireta. 
A direta, ocorre quando passamos o parâmetro passo do componente filho (PassoForm) para o 
componente pai (Contador), isso via props. A comunicação indireta, ocorre ao passar uma 
função ao componente filho (setPasso={this.setPasso}), e quando o evento acontece o filho 
manda de volta a informação do novo passo (+e.target.value)


* Como boa prática de desenvolvimento, podemos criar uma pasta de views e outra de 
components, em views iremos colocar componentes que representa telas inteiras e em components, 
componentes que representam partes de uma tela.

* O componente Link de navegação gera uma tag a

* Dentro de um conteudo dinâmico, ou seja, que vai exibir componentes de navegação, se colocarmos o componente Home logo de inicio, todos os outros vão navegar para home, pois todas as rotas inicia, em '/...'
Ex:
import React from 'react'
import { Switch, Route } from 'react-router-dom'

import About from '../../views/examples/About'
import Home from '../../views/examples/Home'
import Param from '../../views/examples/Param'

import './Content.css'

export default _ => {

    return (
        <main className="Content">
            <Switch>
		<Route path="/">
                    <Home></Home>
                </Route>
                <Route path="/about">
                    <About></About>
                </Route>
                <Route path="/param/:id">
                    <Param></Param>
                </Route>
            </Switch>
        </main>
    )
}

Para evitar isso, podemos passar exact path = '/', que nesse caso, só navega para Home se a url for exata
A vantagem de não ter o exact e colocar o Home por ultima nas rotas, é que uma rota inexistente, vai direcionar para home.
As rotas existentes não, pois, ele encontra o caminho antes.

Podemos tambem criar um componente para erro de página não encontrada, basta listar a rota no final, em Content.jsx

Ex:

 -> Em NotFound.jsx:
import React from 'react'

export default _ => {

    return (
        <div className="Not Found">
            <h1>404</h1>
            <h2>Página Não encontrada</h2>
        </div>
    )
}

 -> Em Content.jsx:
import React from 'react'
import { Switch, Route } from 'react-router-dom'

import About from '../../views/examples/About'
import Home from '../../views/examples/Home'
import Param from '../../views/examples/Param'
import NotFound from '../../views/examples/NotFound'

import './Content.css'

export default _ => {

    return (
        <main className="Content">
            <Switch>
                <Route path="/about">
                    <About></About>
                </Route>
                <Route path="/param/:id">
                    <Param></Param>
                </Route>
                <Route exact path="/">
                    <Home></Home>
                </Route>
                <Route path="*">
                    <NotFound></NotFound>
                </Route>
            </Switch>
        </main>
    )
}


* Componentes controlados são componentes que só atualizam se houver uma alteração do estado do componente (backend), ou seja, não ha alteração via usuário, para refleter a sensação de atualização, é necessário receber essa alteração do usuário, para então, passar isso para o estado, alterar o estado, o que vai refletir no elemento visual.
Essa alteração do estado é realizada capturando um evento.
Podemos deixar um compontent (input, textarea e select) não controlado, atribuindo null para o parâmetro value.

* UseEffect, é um hooks, que permite executar efeitos colaterais em componentes funcionais, ou seja, caso ocorra alteração de um componente, isso reflita em outro.

* Não podemos chamar um função de alteração de componente dentro do corpo da funcão do componente, pois essa chamada vai alterar o estado, e esse corpo da função, é responsável por renderizar o componente, se chamar essa alteração direto no corpo, isso vai alterar o estado, o que vai renderizar o componente, e novamente alterar o estado e renderizar, e assim por diante, infinitamente, gerando um erro.
Para resolver isso, podemos usar o useEffect, que vai receber dois parâmetros, o primeiro, uma função callback, que vai ser a função chamada quando determinado valor ser alterado, e o segundo parâmetro, um array de dependencias, ou seja, de valores que alterados vão chamar essa função callback.

* useRef é um hooks que retorna um objeto mutável com a propriedade .current. o useRef vai retornar a referência de um objeto, sempre a mesma referência. E dentro desse objeto, conseguimos ter o estado atual através da propriedade current. Sempre que o objeto for renderizado, vamos ter acesso a esse objeto com a mesma referência. Quando o current de useRef é alterado, não ha necessidade de renderizar novamente o componente.
Resumindo, o useRef vai criar um objeto mutável, no sentido que os atributos internos podem ser alterados, enquanto os atributos forem renderizados, estaremos com o mesmo objeto, se sair da tela e voltar, recebemos um novo objeto, mas enquando tiver renderizando, ele vai retornar a mesma referencia.
Diferente do useState, onde toda modificação de estado, o componente é renderizado novamente.

* Com useRef, podemos obter a referência de um determinado elemento interno de nosso componente, basta atribuir o valor dentro do parâmetro ref do elemento
Ex:
export default (props) => {

    const [value1, setValue1] = useState()
    const [value2, setValue2] = useState()
    const count = useRef(0)

    const myInput1 = useRef(null)
    const myInput2 = useRef(null)

    console.log(myInput1.current)

    useEffect(() => {
        count.current = count.current + 1 /* Não entra em renderização infinita, pois alteração
        do valor atual de useRef, não renderiza novamente o componente */

        //Colocando dentro de useEffect, só chamaremos o incremento quando value1 for alterado
    }, [value1, value2])

    return (
        <div className="UseRef">
            <PageTitle
                title="Hook UseRef"
                subtitle="Retorna um objeto mutável com a propriedade .current!"
            />
            <SectionTitle title="Exercício #01"></SectionTitle>
            <div className="center">
                <div>
                    <span className="text">Valor: </span>
                    <span className="text">{value1} [</span>
                    <span className="text red">{count.current}</span>
                    <span className="text">]</span>
                </div>
                <input type="text" className="input"
                    ref={myInput1}
                    value={value1} onChange={e => setValue1(e.target.value)}
                />
            </div>
        </div>

    )
}

myInput1 é nosso objeto, e o valor atual agora, é o elemento input, ja que passamos o valor para o parâmetro ref (ref={myInput1})
Em resumo, a referência para current, agora é o elemento input.

Em resumo, as Refs do React servem para acessar elementos nativos como inputs do HTML de uma forma imperativa e realizar ações dentro
desses componentes.

Programação Imperativa x Programação Declarativa:
    O React usa uma programação declarativa, ou seja, ele adapta o seu comportamento
 baseado no estado que ele tem, ou seja, utiliza do estado dos componentes para montar
 a interface (Ex: Dependendo do número de notificações vai mostrar uma mensagem). 
 A programação imperativa, vamos executar operações diretamente no HTML (dar focus, em inputs,
 pegar valores de inputs). Normalmente, com useState, vamos esperar um evento no input, para daí,
 pegar o valor. Com useRef, podemos pegar a informação do componente sem necessidade da renderização
 do componente.

    As vezes nosso componente é muito grande, o que não fica legal, renderizar sempre esse componente
todas as vezes que o input alterar o estado. Com as refs podemos anotar valores sem a necessidade de 
renderizar o componente novamente. Se for necessário, alterar a cor de um botão, por exemplo, quando
um estado muda, ai precisamos usar o useState em vez de useRef.

    Usando um componente input setado com uma ref, a atualização do input, não altera o estado, igual
ao useState, para obter o valor atual, precisamos utilizar o metodo current do objeto criado com a ref.

* o useMemo, vai auxliar para retornar valores de cache de memória.
Se uma operação envolvendo dois input's, por exemplo, for uma operação lenta, a renderização
dessa atualização vai demorar um pouco, o que vai impactar na renderização de outros inputs, o que
não é legal, para resolver isso, temos duas formas:
    1ª useEffect + useState:
        const [result, setResult] = useState(0)
        useEffect(function () {
            setResult(sum(n1, n2))
        }, [n1, n2]); 

        Aqui, o resultado só vai ser chamado quando n1 e n2 forem alterados, podemos alterar outros valores
        tranquilamente que não haverá impacto na renderização
    2ª useMemo:
        const result = useMemo(() => sum(n1, n2), [n1, n2])
        useMemo retorna o valor ja calculado, e só chama a soma, se o valor de n1 ou n2 mude, ou seja,
        é calculado um valor (uma função que demora), ele armazena um cache do valor, e só chama a função
        novamente caso os valores (dependencias) modifiquem.
    Forma que da problema:
    const result = sum(n1, n2) 
    Aqui a função lenta (sum) é chamada sempre que ha renderização ou seja, quando qualquer elemento com estado alterar

* useCallback vai retornar para nós uma função 'cacheada', ou seja, uma função memoizada.
    Ex Sem useCallback:
     -> em UseCallback.jsx:
        import React, { useState } from 'react'
        import PageTitle from '../../components/layout/PageTitle'
        import UseCallbackButtons from './UseCallbackButtons'

        const UseCallback = (props) => {

        const [value, setValue] = useState(0)

        function inc(delta) {
            if (delta === 0) {
            setValue(0)
            } else {
            setValue(value + delta)
            }
        }

        return (
            <div className="UseCallback">
            <PageTitle
                title="Hook UseCallback"
                subtitle="Retorna uma função memoizada!"
            />
            <div className="center">
                <span className="text">{value}</span>
                <UseCallbackButtons incFunc={inc}></UseCallbackButtons>
            </div>
            </div>
        )
        }

        export default UseCallback

    -> Em UseCallbackButtons.jsx:
        import React from 'react';
        const UseCallbackButtons = props => {
        console.log('render...')
        return (
            <div>
            <button className="btn" onClick={() => props.incFunc(6)}>+6</button>
            <button className="btn" onClick={() => props.incFunc(12)}>+12</button>
            <button className="btn" onClick={() => props.incFunc(18)}>+18</button>
            <button className="btn" onClick={() => props.incFunc(0)}>Resetar</button>
            </div>
        );
        }

        export default UseCallbackButtons;

    Aqui, toda vez que clicamos em algun dos botões, nos atualizamos um elemento dos componentes filho, no caso o
    nosso span, porem, ao fazer isso, outro componente filho, o <UseCallbackButtons> tambem é renderizado, pois
    o componente pai precisa ser renderizado, renderizando todos os filhos, porem, o componente <UseCallbackButtons>
    não precisa ser renderizado, ja que não houve nenhuma alteração de estado nos elementos desse componente e isso
    pode ser feito com o useCallback.
        
    Ao exportar com React.memo(), o <UseCallbackButtons> só vai ser renderizado quando alguma das props
    desse componente for atualizada, ou seja, se tivermos passando um novo número ou uma nova função.
    Nesse exemplo, isso acontece, pois, todas as vezes que renderizados o componente pai, a função inc()
    é definida novamente, ou seja, uma 'nova' função, renderizando os botões. Para resolver isso, temos 
    que colocar a função para fora do componente, o que não funciona, ja que essa função usa o setCount,
    que é definido dentro do componente. A solução aqui, é usar o useCallback. Onde vamos definir essa função 
    uma única vez, e só alterar.

    Ex: 
        -> Em useCallback.jsx:
            import React, { useCallback, useState } from 'react'
            import PageTitle from '../../components/layout/PageTitle'
            import UseCallbackButtons from './UseCallbackButtons'

            const UseCallback = (props) => {

            const [value, setValue] = useState(0)

            const inc = useCallback(function (delta) {
                if (delta === 0) {
                setValue(0)
                } else {
                setValue(curr => curr + delta)
                }
            }, [setValue])

            return (
                <div className="UseCallback">
                <PageTitle
                    title="Hook UseCallback"
                    subtitle="Retorna uma função memoizada!"
                />
                <div className="center">
                    <span className="text">{value}</span>
                    <UseCallbackButtons incFunc={inc}></UseCallbackButtons>
                </div>
                </div>
            )
            }

            export default UseCallback

        -> Em UseCallbackButtons.jsx:
            import React from 'react';

            const UseCallbackButtons = props => {
            console.log('render...')
            return (
                <div>
                <button className="btn" onClick={() => props.incFunc(6)}>+6</button>
                <button className="btn" onClick={() => props.incFunc(12)}>+12</button>
                <button className="btn" onClick={() => props.incFunc(18)}>+18</button>
                <button className="btn" onClick={() => props.incFunc(0)}>Resetar</button>
                </div>
            );
            }

            export default React.memo(UseCallbackButtons);

        Aqui, a nossa função inc, será criada agora uma unica vez, e só vai alterar se depêndencia
        alterar, no caso passamos setValue como depêndencia, e o setValue é definido uma única vez.
        Dessa forma, ao exportar nosso button com React.memo() criamos um cache dos parâmetros que 
        são passados, no caso, apenas a funçao inc, e esse componente só vai renderizar uma única
        vez, pois a função que passamos (incFunc={inc}) se essa função
        alterar, ou seja, não vai, pois setValue é constante. Em resumo, vamos passar sempre a mesma
        função, sem a necessidade de ficar criando novas, pois o React.memo() armazenou em cache.

        O useCallback deve ser usado quando temos função sendo passada, quando são apenas valores,
        podemos usar o useMemo.

* Context API, é uma API do React, que vai facilitar a comunicação entre componentes, sem a necessidade
de envolver diversos outros componentes para isso, ela vai criar um componente fora da nossa App, que
vai enxergar todos os componentes e armazenar informações deles, facilitando essa comunicação.
Com isso conseguimos alterar um dado em determinado componente e refletir isso em outro componente
mais distante. Aqui não há necessidade das comunicações direta (pai para filho) e indireta (filho para pai).
OBS: Context API é normalmente usado com useReducer, que é uma alternativa ao useState para casos mais
complexos.

* Com context API, precisamos primeiro criar um objeto de contexto
Ex:
 -> Em src/data/DataContext.js:
    import React from 'react';
    export const data = {
    number: 123,
    text: "Context API"
    }

    const DataContext = React.createContext(data) //o createContext vai criar esse objeto onde vamos consumir esses dados

    export default DataContext

Agora precisamos sinalizar que esses dados vão ser acessíveis por todos os compoments, para isso, precisamos envolver
nossa aplicação com DataContext.Provider.
Ex:
    -> Em App.jsx:
        import './App.css'
        import React from 'react'
        import { BrowserRouter as Router } from 'react-router-dom'
        import Menu from '../components/layout/Menu'
        import Content from '../components/layout/Content'
        import DataContext, { data } from '../data/DataContext'

        const App = props => {
        return (
            <DataContext.Provider value={data}>
            <div className="App">
                <Router>
                <Menu />
                <Content />
                </Router>
            </div>
            </DataContext.Provider>

        )
        }

        export default App

Um outra forma, é atrelar esses dados (data) dentro de um estado. Aqui tem que ter o cuidado, pois
o data é um objeto, se atribuir o valor para um número por exemplo, deixa de ser um objeto.
Ex:
    -> Em UseContext.jsx:
    import React, { useContext } from 'react'
    import PageTitle from '../../components/layout/PageTitle'
    import DataContext from '../../data/DataContext'

    const UseContext = (props) => {

    const {state, setState} = useContext(DataContext)

    function addNumber(delta) {
        setState({
        ...state, //Precisamos manter os outros parâmetros aqui, caso contrário, o objeto data, passa a ser apenas o que alteramos, no caso {number: n}
        number: state.number + delta
        })
    }

    return (
        <div className="UseContext">
        <PageTitle
            title="Hook UseContext"
            subtitle="Aceita um objeto de contexto e retorna o valor atual do contexto!"
        />
        <div className="center">
            <span className="text">{state.text}</span>
            <span className="text">{state.number}</span>
        </div>
        <div>
            <button className="btn" onClick={_ => addNumber(1)}> +1 </button>
            <button className="btn" onClick={_ => addNumber(-1)}> -1 </button>
        </div>
        </div>
    )
    }

    export default UseContext

Essa forma de utilizar o context API não é muito legal, pois nosso contexto está disponível em toda
a aplicação, o que pode causar problemas. Precisamos de uma maior encapsulamento. Faremos isso com 
o componete Store, que vai ser responsável por controlar nosso estado, dando esse encapsulamento maior
Onde para os filhos, vamos passar uma função para alterar os parâmetros (updateState), impossibilitando
alguem alterar o estado de uma vez.
Em resumo, o componente Store vai ser o responsável por gerenciar, via função (updateState)
as alterações estado das informação de contexto (number e text), dessa forma, não passamos 
direto a função 'setState', agora passamos uma função 'controladora' para alterar o nosso estado,
dentro da parâmetro value do AppContext.Provider.

Ex:
    -> Em Store.jsx:
        import React, { useState } from 'react';

        const initialState = {
        number: 123,
        text: "Context API + Hooks"
        }

        export const AppContext = React.createContext(initialState)

        const Store = props => {

        const [state, setState] = useState(initialState)

        function updateState(key, value) {
            setState({
            ...state,
            [key]: value
            })
        }

        return (
            <AppContext.Provider value={{
            number: state.number,
            text: state.text,
            setNumber: n => updateState("number", n),
            setText: t => updateState("text", t),
            }}>
            {props.children}
            </AppContext.Provider>
        );
        }

        export default Store;

    -> Em App.jsx:

        import React, { useContext, useEffect } from 'react'
        import PageTitle from '../../components/layout/PageTitle'
        import SectionTitle from '../../components/layout/SectionTitle'
        import DataContext from '../../data/DataContext'
        import { AppContext } from '../../data/Store'

        const UseContext = (props) => {

        //Exercício #01
        const { state, setState } = useContext(DataContext)
        function addNumber(delta) {
            setState({
            ...state, //Precisamos manter os outros parâmetros aqui, caso contrário, o objeto data, passa a ser apenas o que alteramos, no caso {number: n}
            number: state.number + delta
            })
        }

        //Exercício #02
        const { number, text, setNumber, setText } = useContext(AppContext)

        useEffect(function(){
            if(number>=140){
            setText('Vai com calma Jovem...')
            }
        }, [number])

        return (
            <div className="UseContext">
            <PageTitle
                title="Hook UseContext"
                subtitle="Aceita um objeto de contexto e retorna o valor atual do contexto!"
            />
            <SectionTitle title="Exercício #01" />
            <div className="center">
                <span className="text">{state.text}</span>
                <span className="text">{state.number}</span>

                <div>
                <button className="btn" onClick={_ => addNumber(+1)}> +1 </button>
                <button className="btn" onClick={_ => addNumber(-1)}> -1 </button>
                </div>
            </div>
            <SectionTitle title="Exercício #02" />
            <div className="center">
                <span className="text">{text}</span>
                <span className="text">{number}</span>
                <div>
                <button
                    className="btn"
                    onClick={_ => setNumber(number + 1)}> +1 </button>
                <button
                    className="btn"
                    onClick={_ => setNumber(number - 1)}> -1 </button>
                </div>
            </div>
            </div>
        )
        }

        export default UseContext;

* useReducer é uma alternativa ao useState, e nos ajuda a ter uma maior controle
de estado, de evoluir objetos.

Ex:
    -> Em UseReducer.jsx:
    import React, { useReducer } from 'react'
    import PageTitle from '../../components/layout/PageTitle'

    const initialState = {
    cart: [],
    products: [],
    user: null,
    number: 0
    }

    function reducer(state, action) {
    switch (action.type) {
        case 'numberAdd2':
        return { ...state, number: state.number + 2 }
        case 'login':
        return { ...state, user: { name: action.payload } }
        case 'vezes7':
        return { ...state, number: state.number * 7 }
        case 'div25':
        return { ...state, number: state.number / 25 }
        case 'arredondar':
        return { ...state, number: parseFloat(state.number).toFixed(2) }
        case 'addn':
        return { ...state, number: state.number + parseInt(action.payload) }
        default:
        return state
    }
    }

    const UseReducer = (props) => {

    const [state, dispatch] = useReducer(reducer, initialState)

    return (
        <div className="UseReducer">
        <PageTitle
            title="Hook UseReducer"
            subtitle="Uma outra forma de ter estado em componentes funcionais!"
        />
        <div className="center">
            {state.user ?
            <span className="text">{state.user.name}</span>
            : <span className="text">Sem Usuário</span>}
            <span className="text">{state.number}</span>
            <div>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'numberAdd2' })}> + 2</button>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'login', payload: 'Lucas' })}>Logar</button>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'vezes7' })}>x7</button>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'div25' })}>/25</button>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'arredondar' })}>Inteiro</button>
            <button
                className="btn"
                onClick={() => dispatch({ type: 'addn', payload: 3 })}>Add 'n'</button>
            </div>
        </div>
        </div>
    )
    }

    export default UseReducer

Dependendo do tamanho do nossa App, vai ser necessário uma maior organização para alteração dos 
estados.